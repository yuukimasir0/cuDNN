## Graph API

cuDNNライブラリは、計算を操作のグラフとして記述するための宣言的なプログラミングモデルを提供します。
このグラフAPIは、操作の融合の重要性が増す中、より柔軟なAPIを提供するためにcuDNN 8.0で導入されました。

ユーザは操作のグラフを構築することから始めます。
高レベルでは、ユーザはテンソル上の操作のデータフローグラフを記述します。
完成したグラフをもとに、ユーザーはそのグラフを実行できるエンジンを選択します。
エンジンの選択にはいくつかの方法があり、使いやすさ、実行時のオーバーヘッド、エンジン性能に関してトレードオフがあります。

グラフAPIには2つのエントリーポイントがあります:
- Backend Descriptor Types（グラフAPIへの最も低レベルのエントリーポイント）
- NVIDIA cuDNN Frontend API（CバックエンドAPIの上にある便利なレイヤー）

ほとんどのユーザーは次の理由からcuDNNフロントエンドAPIを好むと予想されます:

- 冗長性が少なくても制御の損失はない - バックエンドAPIを通じてアクセス可能なすべての機能がフロントエンドAPIでもアクセス可能。
- バックエンドAPIに追加の機能を提供 - エラーフィルターや自動チューニングなど。
- オープンソース。

どちらの場合でも（バックエンドまたはフロントエンドAPI）、高レベルの概念は同じです。

### 重要な概念

グラフAPIの重要な概念は以下の通りです:

- [操作と操作グラフ](#操作と操作グラフ)
- [エンジンとエンジン設定](#エンジンとエンジン設定)
- [ヒューリスティック](#ヒューリスティック)

これらの概念については、以下のサブセクションで説明します。
後で、これらを結びつける例を示します。

#### 操作と操作グラフ

操作グラフは、テンソル上の操作のデータフローグラフです。これは数学的な仕様を意味しており、それを実装できる基礎となるエンジンから独立しています。グラフに対して利用可能なエンジンが複数存在する可能性があります。

I/Oテンソルは操作を暗黙的に接続します。
例えば、操作AがテンソルXを生成し、それを操作Bが消費する場合、操作Bは操作Aに依存することを意味します。

#### エンジンとエンジン設定

特定の操作グラフに対して、そのグラフを実装する候補となるエンジンがいくつか存在します。候補エンジンのリストを問い合わせる典型的な方法は、以下で説明するヒューリスティッククエリを通じて行われます。

エンジンには、タイルサイズなどのエンジンのプロパティを設定するためのパラメータが存在します（`cudnnBackendKnobType_t`を参照）。

#### ヒューリスティック

ヒューリスティックとは、特定の操作グラフに対して最もパフォーマンスが高いものから最も低いものまでのエンジン設定のリストを取得する方法です。3つのモードがあります:

- `CUDNN_HEUR_MODE_A` - 高速かつほとんどの操作グラフパターンに対応できることを意図しています。予想されるパフォーマンスでランク付けされたエンジン設定のリストを返します。
- `CUDNN_HEUR_MODE_B` - モードAより一般的に正確ですが、エンジン設定リストを返すまでのCPUレイテンシが高いというトレードオフがあります。モードAが良い結果を出せることが分かっている場合には、モードAのヒューリスティックを使うことがあります。
- `CUDNN_HEUR_MODE_FALLBACK` - 高速であり、最適なパフォーマンスを期待せずに機能的な代替案を提供することを意図しています。

推奨されるワークフローは、モードAまたはBのいずれかをクエリし、サポートを確認することです。サポートのある最初のエンジン設定が最もパフォーマンスが高いと予想されます。

自動チューニング、すなわちエンジン設定のリストを繰り返し試し、特定のデバイス上で特定の問題に最適なものを選択することができます。
cuDNNフロントエンドAPIは、これを行う便利な関数`cudnnFindPlan()`を提供します。

## 操作とテンソル記述子の作成によるグラフデータフローの指定

まず、3つのcuDNNバックエンド操作記述子を作成します。

次の図では、ユーザーは1つのフォワード畳み込み操作（`CUDNN_BACKEND_OPERATION_CONVOLUTION_FORWARD_DESCRIPTOR`を使用）、バイアス追加のためのポイントワイズ操作（`CUDNN_BACKEND_OPERATION_POINTWISE_DESCRIPTOR`を使用し、モードは`CUDNN_POINTWISE_ADD`）、およびReLU活性化のためのポイントワイズ操作（`CUDNN_BACKEND_OPERATION_POINTWISE_DESCRIPTOR`を使用し、モードは`CUDNN_POINTWISE_RELU_FWD`）を指定しています。
これらの記述子の属性を設定する詳細については、[Backend Descriptor Types](#)を参照してください。
フォワード畳み込みを設定する方法の例については、[Setting Up An Operation Graph For A Grouped Convolution use case](#)を参照してください。

また、グラフ内のすべての操作の入力と出力のためのテンソル記述子も作成する必要があります。
グラフデータフローはテンソルの割り当てによって暗示されます。
例えば、バックエンドテンソル`Tmp0`を畳み込み操作の出力およびバイアス操作の入力として指定することで、cuDNNはデータフローが畳み込みからバイアスに流れることを推測します。
同様にテンソル`Tmp1`についても同じです。ユーザーが中間結果`Tmp0`および`Tmp1`を他の目的で必要としない場合、これらを仮想テンソルとして指定することができ、後でメモリI/Oを最適化することができます。

> * 複数の操作ノードを持つグラフはインプレース操作をサポートしていません（つまり、入力UIDが出力UIDと一致する場合）。そのようなインプレース操作は後のグラフ解析で循環と見なされ、サポートされません。インプレース操作は単一ノードグラフではサポートされます。
> 
> * 操作記述子は任意の順序で作成し、cuDNNに渡すことができます。テンソルUIDがグラフの依存関係を決定するのに十分です。

![A Set of Operation Descriptors the User Passes to the Operation Graph](#)

### 操作グラフの最終化

次に、ユーザーは操作グラフを最終化します。最終化の一環として、cuDNNはデータフロー解析を行い、操作間の依存関係を確立し、エッジを接続します。以下の図に示すように、cuDNNはこのステップでグラフの有効性を確認するさまざまなチェックを行います。

![The Operation Graph after Finalization](#)

### 操作グラフを実行するエンジンの設定

最終化された操作グラフをもとに、ユーザーはそのグラフを実行するエンジンを選択し、設定します。これは実行計画の結果となります。典型的な方法は次の通りです:

1. ヒューリスティックモードAまたはBをクエリする。
2. 機能的なサポートを持つ最初のエンジン設定を探す（または機能的なサポートを持つすべてのエンジン設定を自動チューニングする）。
3. (2)でエンジン設定が見つからなかった場合、フォールバックヒューリスティックをクエリして追加のオプションを探す。

### エンジンの実行

実行計画が構築され、実行する時が来たら、ユーザーはワークスペースポインタ、UIDの配列、およびデバイスポインタの配列を提供することでバックエンドバリアントパックを構築します。UIDとポインタは対応する順序でなければなりません。ハンドル、実行計画、およびバリアントパックを使用して実行APIを呼び出し、GPU上で計算を実行します。
